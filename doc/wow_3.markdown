WOW 3
=======

The way to combine different midi tracks is by using `(+:+)` and `=:=`. Yes, just like the way we combine Music.T.

from Example.NewResolutions

	part1 = MidiMusic.fromStdMelody marimba (loudness1 0.7 pattern)
	        +:+
	        MidiMusic.fromStdMelody xylo    (loudness1 1.2 melody1)
	    =:= MidiMusic.fromStdMelody marimba (loudness1 0.7 (Music.replicate 4 pattern))
	
By the way, I encourage you to listen to the midi file generated by this example ( inside haskore/Test/MIDI/NewResolutions.midi ), it really shows the power of Haskore / Haskell, and it actually sound nice ( which aren't all true for computer generated musics ).

The reason this works is that we raise Music.T to MIDI.T by `fromMelodyNullAttr` or `fromStdMelody` and

in Music.GeneralMIDI

	import qualified Haskore.Music.Rhythmic  as RhyMusic
	
	type T        = RhyMusic.T        Drum Instr
    
	fromStdMelody :: Instr -> StdMelody.T -> T
	fromStdMelody = RhyMusic.fromStdMelody
    
	fromMelodyNullAttr :: Instr -> Melody.T () -> T
	fromMelodyNullAttr = RhyMusic.fromMelodyNullAttr
	
and in Music.Rhythmic

	type T drum instr = Music.T (Note drum instr)

See? Midi.T transforms back to (seriously need a better word ...) Music.T. This is even better then duck typing.


Adding a drum Track
--------------------

from Example.Miscellanerous

	import qualified Haskore.Interface.MIDI.Render       as Render
	import           Haskore.Composition.Drum  as Drum

	t14 = Render.generalMidiDeflt (Drum.toMusicDefaultAttr AcousticSnare qn)

It generates a single snare drum beat.

from Render

	generalMidiDeflt :: MidiMusic.T -> MidiFile.T

from Drum
	
	toMusic :: drum -> Duration.T -> NoteAttributes -> RhyMusic.T drum instr
	toMusic drm dr nas =
	   Music.atom dr (Just (RhyMusic.noteFromAttrs nas (RhyMusic.Drum drm)))
    
	toMusicDefaultAttr ::
	   drum -> Duration.T -> RhyMusic.T drum instr
	toMusicDefaultAttr drm dr = toMusic drm dr na
	
So we use `toMusic` or `toMusicDefaultAttr` to generate drums. You might have noticed that there is something different then how we generate from melody. Let's recap:

from Melody

	note :: Pitch.T -> Duration.T -> attr -> T attr

Instead of providing a pitch value for melody, we provide an instrument-name for drum.

For a piano, it makes sense to talk about melodies and chords. This does not apply for most of drums. Give me a C chord in snares does not make sense. So a drum instrument is in fact a drum set. You can put many different drums in this set ( assigning C 1 to be a snare drum, D 1 to be a triangle, etc ).

General midi provides a default drum set, so we have a standard drum mapping table.

from Sound.MIDI.General

	data Drum =
	        AcousticBassDrum  -- Midi Key 35
	      | BassDrum1         -- Midi Key 36
	      | SideStick         -- ...
	      | AcousticSnare | HandClap      | ElectricSnare | LowFloorTom
	      | ClosedHiHat   | HighFloorTom  | PedalHiHat    | LowTom
	      | OpenHiHat     | LowMidTom     | HiMidTom      | CrashCymbal1
		  ...


Let's hear what general midi offers:
	
	import Haskore.Composition.Drum  as Drum
	import Sound.MIDI.General as MIDI
	
	drum_enum = export_to' "wow_3" 2 $ M.line $ map (\d ->  Drum.toMusicDefaultAttr d en) MIDI.drums

[GM Drums](../midi/wow_3/wow_3_1.midi?raw=true)