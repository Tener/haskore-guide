WOW 3
=======

The way to combine different midi tracks is by using `(+:+)` and `=:=`. Yes, just like the way we combine Music.T.

from Example.NewResolutions

	part1 = MidiMusic.fromStdMelody marimba (loudness1 0.7 pattern)
	        +:+
	        MidiMusic.fromStdMelody xylo    (loudness1 1.2 melody1)
	    =:= MidiMusic.fromStdMelody marimba (loudness1 0.7 (Music.replicate 4 pattern))
	
By the way, I encourage you to listen to the midi file generated by this example ( inside haskore/Test/MIDI/NewResolutions.midi ), it really shows the power of Haskore / Haskell, and it actually sound nice ( which aren't all true for computer generated musics ).

The reason this works is that we raise Music.T to MIDI.T by `fromMelodyNullAttr` or `fromStdMelody` and

in Music.GeneralMIDI

	import qualified Haskore.Music.Rhythmic  as RhyMusic
	
	type T        = RhyMusic.T        Drum Instr
    
	fromStdMelody :: Instr -> StdMelody.T -> T
	fromStdMelody = RhyMusic.fromStdMelody
    
	fromMelodyNullAttr :: Instr -> Melody.T () -> T
	fromMelodyNullAttr = RhyMusic.fromMelodyNullAttr
	
and in Music.Rhythmic

	type T drum instr = Music.T (Note drum instr)

See? Midi.T transforms back to (seriously need a better word ...) Music.T. This is even better then duck typing.


Add drums
--------------------

from Example.Miscellanerous

	import qualified Haskore.Interface.MIDI.Render       as Render
	import           Haskore.Composition.Drum  as Drum

	t14 = Render.generalMidiDeflt (Drum.toMusicDefaultAttr AcousticSnare qn)

It generates a single snare drum beat.

from Render

	generalMidiDeflt :: MidiMusic.T -> MidiFile.T

from Drum
	
	toMusic :: drum -> Duration.T -> NoteAttributes -> RhyMusic.T drum instr
	toMusic drm dr nas =
	   Music.atom dr (Just (RhyMusic.noteFromAttrs nas (RhyMusic.Drum drm)))
    
	toMusicDefaultAttr ::
	   drum -> Duration.T -> RhyMusic.T drum instr
	toMusicDefaultAttr drm dr = toMusic drm dr na
	
So we use `toMusic` or `toMusicDefaultAttr` to generate drums. You might have noticed that there is something different then how we generate from melody. Let's recap:

from Melody

	note :: Pitch.T -> Duration.T -> attr -> T attr

Instead of providing a pitch value for melody, we provide an instrument-name for drum.

For a piano, it makes sense to talk about melodies and chords. This does not apply for most of drums. Give me a C chord in snares does not make sense. So a drum instrument is in fact a drum set. You can put many different drums in this set ( assigning C 1 to be a snare drum, D 1 to be a triangle, etc ).

General midi provides a default drum set, so we have a standard drum mapping table.

from Sound.MIDI.General

	data Drum =
	        AcousticBassDrum  -- Midi Key 35
	      | BassDrum1         -- Midi Key 36
	      | SideStick         -- ...
	      | AcousticSnare | HandClap      | ElectricSnare | LowFloorTom
	      | ClosedHiHat   | HighFloorTom  | PedalHiHat    | LowTom
	      | OpenHiHat     | LowMidTom     | HiMidTom      | CrashCymbal1
		  ...


Let's hear what general midi offers:
	
	import Haskore.Composition.Drum  as Drum
	import Sound.MIDI.General as MIDI
	
	drum_enum = export_to' "wow_3" 2 $ M.line $ map (\d ->  Drum.toMusicDefaultAttr d en) MIDI.drums

[GM Drums](../midi/wow_3/wow_3_1.midi?raw=true)

Now we build our naive drum track

	drum = Drum.toMusicDefaultAttr

	drum_1 = M.replicate 8 $ M.line [
	  drum OpenHiConga qn,
	  drum LowConga hn,
	  loudness1 0.5 $ drum LowFloorTom qn,
	  drum LowConga hn
	  ]

	drum_2_var_1 = [
	  drum LowBongo dqn,
	  drum LowBongo dqn,
	  drum LowBongo hn,
	  enr,
	  drum LowConga en
	  ]

	drum_2_var_2 = [
	  drum LowBongo en
	  ] ++ P.replicate 5 (drum LowConga en) ++ [
	  drum LowBongo hn,
	  rest (1 %+ 12),
	  drum LowConga (2 %+ 12)
	  ]

	drum_2 =  (+:+) sfnr $ loudness1 0.6 $ M.replicate 2 $ M.line . concat $
	  [drum_2_var_1, drum_2_var_1, drum_2_var_2, drum_2_var_1] 

	drum_track = loudness1 1.5 $ drum_1 =:= drum_2


[with drums](../midi/wow_3/wow_3_2.midi?raw=true)

Add a base 
-----------

	base = play_with Cello $ fs (-2) 12 ()
	base_track = loudness1 0.8 base


[with base](../midi/wow_3/wow_3_3.midi?raw=true)

Add two guitars
----------------

	-- guitar_base
	guitar_base = M.line $ map (\n -> n 1 (wn + dqn) () +:+ enr) [
	  cs, cs, cs, cs, cs, cs, d, cs
	  ]

	guitar_base_track = accent 0.6 $ play_with AcousticGuitarNylon guitar_base

	-- guitar fill
	guitar_fill_common = M.line [
	  qnr, fs 1 en (), fs 1 en (), enr, fs 1 en (), fs 1 qn (), fs 1 qn ()
	  ]

	guitar_fill_var_1 = gs 1 qn ()
	guitar_fill_var_2 = e 1 qn ()

	guitar_fill = M.line $ [
	  guitar_fill_common, accent 0.4 guitar_fill_var_1,
	  guitar_fill_common, guitar_fill_var_2,
	  guitar_fill_common, accent 0.3 guitar_fill_var_1,
	  guitar_fill_common, guitar_fill_var_2,
	  guitar_fill_common, accent 0.4 guitar_fill_var_1,
	  guitar_fill_common, guitar_fill_var_2
	  ] ++ P.concat (P.replicate 2 [guitar_fill_common, guitar_fill_var_2])

	guitar_fill_track = loudness1 0.9 $ play_with AcousticGuitarNylon guitar_fill

FIXME: I'm starting to experience random loss of notes in generated midi, for reasons unclear.

[with guitar melodies](../midi/wow_3/wow_3_5.midi?raw=true)



Add two more guitars
---------------------

	-- guitar chord
	c_template xs d = M.chord $ map (\n -> n d () ) xs
	c_1 = c_template [fs 1, a 1, cs 2]
	c_2 = c_template [fs 1, a 1, d 2]

	guitar_chord_1_var_template c = M.line [
	  rest (3 %+ 8 - t ), c t, c (3 %+ 8 - t ), c t   
	  ]
	  where t = 3 %+ 24

	guitar_chord_1_var_1 = guitar_chord_1_var_template c_1
	guitar_chord_1_var_2 = guitar_chord_1_var_template c_2

	guitar_chord_1 = M.replicate 12 guitar_chord_1_var_1 +:+ 
	  M.replicate 2 guitar_chord_1_var_2 +:+ M.replicate 2 guitar_chord_1_var_1

	c_3 = c_template [a 1, cs 2, fs 2]
	c_4 = c_template [a 1, d 2, fs 2]
	guitar_chord_2_var_template c = M.line [
	  c dqn, dqnr
	  ]

	guitar_chord_2_var_1 = guitar_chord_2_var_template c_3 +:+ accent 0.2 (guitar_chord_2_var_template c_3)
	guitar_chord_2_var_2 = guitar_chord_2_var_template c_4 +:+ accent 0.2 (guitar_chord_2_var_template c_4)

	guitar_chord_2 = M.replicate 6 guitar_chord_2_var_1 +:+ 
	  M.replicate 1 guitar_chord_2_var_2 +:+ M.replicate 1 guitar_chord_2_var_1

	guitar_chord_track_1 = 
	  loudness1 0.4 $ play_with AcousticGuitarSteel guitar_chord_1

	guitar_chord_track_2 = 
	  loudness1 0.4 $ play_with ElectricGuitarMuted guitar_chord_2

[with guitar chords](../midi/wow_3/wow_3_6.midi?raw=true)